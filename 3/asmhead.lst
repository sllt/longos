     1 00000000                                 ; long-os boot asm
     2 00000000                                 ;==================================================================
     3 00000000                                 ; @sllt
     4 00000000                                 ; 该段代码是为进入保护模式做准备
     5 00000000                                 ; 然后正式进入保护模式
     6 00000000                                 ; 再重新安排数据在内存中的分布
     7 00000000                                 ; 最终跳入C语言程序
     8 00000000                                 ;==================================================================
     9  = 00280000                              BOTPAK  EQU     0x00280000      ; 内核代码段基址
    10  = 00100000                              DSKCAC  EQU     0x00100000      ; ipl10的512B将被移动到该地址处 (1M)
    11  = 00008000                              DSKCAC0 EQU     0x00008000      ; 软盘中的数据将被加载到的内存起始地址(事实上0x8000~0x81ff这512B没有用到
    12 00000000                                                                 ; 作者只是"虚构"了一个启动区在这个地址段, 事实上软盘的第一个扇区还是在0x7c00处
    13 00000000                                                                 ; 不过从0x8200开始确实是软盘的第二扇区的内容)
    14 00000000                                 
    15 00000000                                 ; BOOT_INFO
    16  = 00000FF0                              CYLS    EQU     0x0ff0          ; 0xff0中存放着在ipl10中读入的柱面数
    17  = 00000FF1                              LEDS    EQU     0x0ff1
    18  = 00000FF2                              VMODE   EQU     0x0ff2          ; 该地址处存放关于颜色数目的信息。颜色的位数
    19  = 00000FF4                              SCRNX   EQU     0x0ff4          ; 该地址处存放分辨率的X
    20  = 00000FF6                              SCRNY   EQU     0x0ff6          ; 该地址处存放分辨率的Y
    21  = 00000FF8                              VRAM    EQU     0x0ff8          ; 该地址处存放图像缓冲区的开始地址
    22 00000000                                 
    23                                                  ORG     0xc200          
    24 0000C200                                 
    25 0000C200                                 ; 保存启动信息
    26 0000C200                                 
    27 0000C200 B0 13                                   MOV     AL,0x13         ; VGA显卡，320*100*8位彩色
    28 0000C202 B4 00                                   MOV     AH,0x00
    29 0000C204 CD 10                                   INT     0x10
    30 0000C206 C6 06 0FF2 08                           MOV     BYTE [VMODE],8  ; 记录画面模式
    31 0000C20B C7 06 0FF4 0140                         MOV     WORD [SCRNX],320
    32 0000C211 C7 06 0FF6 00C8                         MOV     WORD [SCRNY],200
    33 0000C217 66 C7 06 0FF8 000A0000                  MOV     DWORD [VRAM],0x000a0000
    34 0000C220                                 
    35 0000C220                                 ; 用BIOS取得键盘上各种LED指示灯的状态
    36 0000C220                                 
    37 0000C220 B4 02                                   MOV     AH,0x02
    38 0000C222 CD 16                                   INT     0x16            ; keyboard BIOS
    39 0000C224 A2 0FF1                                 MOV     [LEDS],AL
    40 0000C227                                 
    41 0000C227                                 ; 下面的代码是为进入保护模式做准备
    42 0000C227                                 
    43 0000C227                                 ;---------------------------------------------------------------------- 
    44 0000C227                                 ;   可以认为该段代码执行之后  CPU将不再响应任何中断       
    45 0000C227 B0 FF                                   MOV     AL,0xff         
    46 0000C229 E6 21                                   OUT     0x21,AL         ; 屏蔽主pic的所有中断
    47 0000C22B 90                                      NOP                     
    48 0000C22C E6 A1                                   OUT     0xa1,AL         ; 屏蔽从pic的所有中断   
    49 0000C22E                                 
    50 0000C22E FA                                      CLI                     ; 关闭所有可屏蔽中断
    51 0000C22F                                  
    52 0000C22F                                 ; 打开A20地址总线
    53 0000C22F E8 00B5                                 CALL    waitkbdout      ; 清空i8042的输入缓冲区
    54 0000C232 B0 D1                                   MOV     AL,0xd1
    55 0000C234 E6 64                                   OUT     0x64,AL         
    56 0000C236 E8 00AE                                 CALL    waitkbdout
    57 0000C239 B0 DF                                   MOV     AL,0xdf         ; enable A20
    58 0000C23B E6 60                                   OUT     0x60,AL
    59 0000C23D E8 00A7                                 CALL    waitkbdout 
    60 0000C240                                 
    61 0000C240                                 [INSTRSET "i486p"]              
    62 0000C240                                 
    63 0000C240 0F 01 16 C32A                           LGDT    [GDTR0]         ; 加载GDTR寄存器
    64 0000C245 0F 20 C0                                MOV     EAX,CR0     
    65 0000C248 66 25 7FFFFFFF                          AND     EAX,0x7fffffff  ; 禁止分页机制
    66 0000C24E 66 83 C8 01                             OR      EAX,0x00000001  ; 开启保护模式
    67 0000C252 0F 22 C0                                MOV     CR0,EAX
    68 0000C255 EB 00                                   JMP     pipelineflush   ; 必须跟一个跳转指令
    69 0000C257                                  
    70 0000C257                                 ; 此后的代码运行于保护模式下
    71 0000C257                                 pipelineflush:
    72 0000C257 B8 0008                                 MOV     AX,1*8          ; 重新设置段寄存器
    73 0000C25A 8E D8                                   MOV     DS,AX           ; DS, ES, FS, GS, SS都指向GDT中的内核数据段描述符
    74 0000C25C 8E C0                                   MOV     ES,AX
    75 0000C25E 8E E0                                   MOV     FS,AX
    76 0000C260 8E E8                                   MOV     GS,AX
    77 0000C262 8E D0                                   MOV     SS,AX
    78 0000C264                                 
    79 0000C264                                 ; 将DS:ESI指向的512KB的内容复制到ES:EDI指向的内存单元
    80 0000C264                                 ; DS:ESI = 8:该文件随后的位置
    81 0000C264                                 ; ES:EDI = 8:0x00280000 (内核代码段的基地址是0x00280000)
    82 0000C264                                 ; 所以这段代码可以认为是该文件之后的512KB内容(内核代码)复制到0x00280000处
    83 0000C264                                 ; 实际上内核代码并没有512KB那么大
    84 0000C264 66 BE 0000C330                          MOV     ESI,bootpack    
    85 0000C26A 66 BF 00280000                          MOV     EDI,BOTPAK      
    86 0000C270 66 B9 00020000                          MOV     ECX,512*1024/4
    87 0000C276 E8 0075                                 CALL    memcpy
    88 0000C279                                 
    89 0000C279                                 ; 将启动扇区的代码复制到0x00100000处 (1M)
    90 0000C279 66 BE 00007C00                          MOV     ESI,0x7c00      
    91 0000C27F 66 BF 00100000                          MOV     EDI,DSKCAC      
    92 0000C285 66 B9 00000080                          MOV     ECX,512/4
    93 0000C28B E8 0060                                 CALL    memcpy
    94 0000C28E                                 
    95 0000C28E                                 ; 将从软盘中读入的数据从0x8200处复制到0x00100200处
    96 0000C28E 66 BE 00008200                          MOV     ESI,DSKCAC0+512 ; ESI = 0x8200
    97 0000C294 66 BF 00100200                          MOV     EDI,DSKCAC+512  ; EDI = 0x00100200
    98 0000C29A 66 B9 00000000                          MOV     ECX,0
    99 0000C2A0 8A 0E 0FF0                              MOV     CL,BYTE [CYLS]  ; CL = 共读入的柱面数
   100 0000C2A4 66 69 C9 00001200                       IMUL    ECX,512*18*2/4  ; 一共要复制的次数
   101 0000C2AB 66 81 E9 00000080                       SUB     ECX,512/4       ; 减去(启动扇区的字节数/4)
   102 0000C2B2 E8 0039                                 CALL    memcpy
   103 0000C2B5                                 
   104 0000C2B5                                 ; bootpack的启动
   105 0000C2B5 66 BB 00280000                          MOV     EBX,BOTPAK      ; EBX = 0x00280000
   106 0000C2BB 67 66 8B 4B 10                          MOV     ECX,[EBX+16]    ; ECX = 0x11a8
   107 0000C2C0 66 83 C1 03                             ADD     ECX,3           ; ECX += 3;
   108 0000C2C4 66 C1 E9 02                             SHR     ECX,2           ; ECX /= 4;
   109 0000C2C8 74 10                                   JZ      skip            ; 没有要传送的数据时
   110 0000C2CA 67 66 8B 73 14                          MOV     ESI,[EBX+20]    ; 复制的源地址(相对于bootoack.hrb头部的偏移) ESI = 0x10c8
   111 0000C2CF 66 01 DE                                ADD     ESI,EBX         ; 换算出要复制的数据的实际物理地址
   112 0000C2D2 67 66 8B 7B 0C                          MOV     EDI,[EBX+12]    ; 复制的目的地址   EDI = 0x310000
   113 0000C2D7 E8 0014                                 CALL    memcpy
   114 0000C2DA                                 skip:
   115 0000C2DA 67 66 8B 63 0C                          MOV     ESP,[EBX+12]    ; 栈初始值  ESP = 0x310000
   116 0000C2DF 66 EA 0000001B 0010                     JMP     DWORD 2*8:0x0000001b
   117 0000C2E7                                 
   118 0000C2E7                                 ; 该子程序与void wait_KBC_sendready(void)函数是一样的 只不过一个用汇编写 一个用C语言写
   119 0000C2E7                                 waitkbdout:                     
   120 0000C2E7 E4 64                                   IN       AL,0x64        ; 从0x64端口读取数据
   121 0000C2E9 24 02                                   AND      AL,0x02        ; 测试i8042输入缓冲区是否为空
   122 0000C2EB 75 FA                                   JNZ     waitkbdout      ; 若不为空 则继续读取 直到输入缓冲区为空为止
   123 0000C2ED C3                                      RET                     ; 为空 则返回
   124 0000C2EE                                 
   125 0000C2EE                                 ; 该函数将DS:ESI指向的内存单元的内容复制到ES:EDI指向的内存单元
   126 0000C2EE                                 ; 每次复制4个字节
   127 0000C2EE                                 memcpy:
   128 0000C2EE 67 66 8B 06                             MOV     EAX,[ESI]       
   129 0000C2F2 66 83 C6 04                             ADD     ESI,4
   130 0000C2F6 67 66 89 07                             MOV     [EDI],EAX
   131 0000C2FA 66 83 C7 04                             ADD     EDI,4
   132 0000C2FE 66 83 E9 01                             SUB     ECX,1
   133 0000C302 75 EA                                   JNZ     memcpy          
   134 0000C304 C3                                      RET
   135 0000C305                                 ;---------------------------------------------------------------------- 
   136 0000C305                                 ;   全局描述符表以及GDTR寄存器的内容
   137 0000C305 00 00 00 00 00 00 00 00 00 00           ALIGNB  16              ; 内存以16字节对齐 (个人猜想 不过内存对齐是肯定的)
       0000C30F 00 
   138 0000C310                                 GDT0:
   139 0000C310 00 00 00 00 00 00 00 00                 RESB    8               ; 空描述符
   140 0000C318 FFFF 0000 9200 00CF                     DW      0xffff,0x0000,0x9200,0x00cf ;   32位可读写数据段描述符    段限长 4G-1    段基址为0   
   141 0000C320                                                                             ;   也就是说该段可寻址0~4G-1 DPL = 0 内核数据段
   142 0000C320 FFFF 0000 9A28 0047                     DW      0xffff,0x0000,0x9a28,0x0047 ;   32位可读可执行代码段描述符  段限长512KB        段基址为0x280000
   143 0000C328                                                                             ;   DPL = 0 内核代码段
   144 0000C328                                 
   145 0000C328 0000                                    DW      0
   146 0000C32A                                 GDTR0:                                      
   147 0000C32A 0017                                    DW      8*3-1                       ; GDT限长
   148 0000C32C 0000C310                                DD      GDT0                        ; GDT基址
   149 0000C330                                 
   150 0000C330                                         ALIGNB  16
   151 0000C330                                 bootpack:
